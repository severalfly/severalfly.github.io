---
layout: default
title: java 并发编程实战
---

# final 使用
此关键字使用过程中需要注意的问题，引用不可变，值可变；如果是基本类型，如`int`，则值也不可变
```

		FinalChangeObject obj = new FinalChangeObject();
		obj.setC(1);

		final FinalChangeObject t = obj;
		obj.setC(2);
		System.out.println(t.getC());

		FinalChangeObject obj2 = new FinalChangeObject();
		//		t = obj2;  //  这里就会报错，t 已经初始化引用到obj了，不能再改变其引用
		// 但是：对象的值是可以修改的，如上面的 obj.setC(2);
```



# 组合使线程安全

> 当为现有的类添加一个原子操作时，有一种更好的文法：组合（compostion）。通过自身的内置锁增加了一层额外的锁，它并不关心底层的list 是否是线程安全的，即使list 不是线程安全的或者修改了它的加锁实现，ImprovedList 也会提供一致的加锁机制来实现线程安全性。虽然额外的同步层可能导致轻微的性能损失，但与模拟另一个对象的加锁策略相比，ImporovedList 更为健壮。事实上，我们使用了java 监视器模式来封装现有的List，并且只要在类中拥有指向底层List 的唯一外部引用，就能确保线程安全性



### 6.2.1 基于`Executor` 的web 服务器示例

这是一段基于线程池的代码示例。通过使用`Executor`将请求处理任务的提交与任务的实际处理解耦开来

### 6.2.2 执行策略
通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的`What, Where, When, How`

在实际编程中，每当看到下面这种形式的代码时  
`new Thread(runnable).start()`  
并且你希望获得一种更灵活的执行策略时，就可以考虑使用`Executor`来代替`Thread`

### 6.2.4 `Executor` 生命周期
有几种停止的方法，使用时来查

### 6.2.5 延迟任务与周期任务
都使用`newScheduledThreadPoolExecutor`就可以了，Timer已经过时，不可用


### 6.3.3 使用Future 实现页面渲染器
> 为了拿页面渲染器实现更就的并发性，首先将渲染过程分解为两个任务，一个是渲染所有的文本，另一个是下载所有的图像。（因为其中一个任务是CPU 密集型，而另一个是I/O密集型，因此这种方法即使在单CPU系统上也能提升性能）

## 第六章总结
> 通过围绕任务执行来设计应用程序，可以简化开发过程，并有助于实现并发，`Executor`框架将任务提交与执行策略解耦开来，同时还支持多种不同类型的执行策略。当需要创建线程来执行任务时，可以考虑使用`Executor`。要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。某些应用程序中存在着比较明示的任务边界，而在其他一些程序中，则需要进一步分析才能提示出粒度理细的并行性。

